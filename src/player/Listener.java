package player;

import grammar.ABCLyricLexer;
import grammar.ABCLyricParser;
import grammar.ABCMusicBaseListener;
import grammar.ABCMusicLexer;
import grammar.ABCMusicParser;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map.Entry;

import org.antlr.v4.codegen.model.chunk.ThisRulePropertyRef_ctx;
import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.TokenStream;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.ParseTreeListener;
import org.antlr.v4.runtime.tree.ParseTreeWalker;

import sound.Pitch;
import sound.PitchCalculator;

public class Listener extends ABCMusicBaseListener {
    private ArrayList<MusicalPhrase> phrases;
    private ArrayList<Bar> bars;
    
    // Instance variables in header
    private String title, composer, key;
    private int meterNumerator, meterDenominator, 
                          tempoNumerator, tempoDenominator, tempoSpeed,
                          lengthNumerator, lengthDenominator;
    private boolean hasDefaultLength, hasTempo;
    
    // Instance variables in body
    private Bar currentBar;
    private String currentVoice;
    private Pitch pitch;
    private String baseNote;
    private int noteNumerator, noteDenominator, chordN, chordD;
    private boolean isChord, isTuplet, isRepeatOn, isOneTwoRepeat;
    private ArrayList<Note> chord, tuplet;
    private ArrayList<Bar> repeatBars;
    private Bar currentRepeatBar;
    private ArrayList<Bar> barsInLine;
    private HashMap<String, Voice> voiceHash = new HashMap<String, Voice>();
    private HashMap<String, Integer> measureAccidentals = new HashMap<String, Integer>();
    PitchCalculator pitchCalculator = new PitchCalculator();
    
    /**
     * Removes all whitespace at the beginning of the string passed in.
     * @param s String to pass in.
     * @return s without all the whitespaces in the beginning.
     */
    public String removeWhitespaceAtBeginning(String s) {
        int whitespaceCounter;
        for (whitespaceCounter = 0; whitespaceCounter < s.length(); whitespaceCounter++) {
            if (s.charAt(whitespaceCounter) != ' ' && s.charAt(whitespaceCounter) != '\t') {
                break;
            }
        }
        return s.substring(whitespaceCounter);       
    }    

    /** 
     * Returns the musical piece that has been generated by the listener.
     * @return Musical piece generated by the listener.
     */
    public MusicalPiece getMusicalPiece() {
        return new MusicalPiece(this.title, this.composer, this.meterNumerator, this.meterDenominator, 
                                                          this.tempoSpeed, this.tempoNumerator, this.tempoDenominator, this.phrases);
    }
    
    //
    // METHODS FOR HANDLING WHEN THE LISTENER ENTERS AND EXITS THE HEADER 
    //
    
    @Override
    /**
     * Initializes default parameters for the musical piece at the very beginning
     * when the listener enters the tree.
     * @param ctx Context for the whole abc file
     */
    public void enterAbc_tune(ABCMusicParser.Abc_tuneContext ctx) {
        this.phrases = new ArrayList<MusicalPhrase>();
        this.bars = new ArrayList<Bar>();
        this.meterNumerator = 4;
        this.meterDenominator = 4;
        this.composer = "Unknown";
        this.repeatBars = new ArrayList<Bar>();
    }

    @Override
    /**
     * Sets the title of the piece when the listener leaves the title node.
     * @param ctx Context for title
     */
    public void exitField_title(ABCMusicParser.Field_titleContext ctx) {
        String title = ctx.ITITLE().getText();
        title = title.substring(2);
        this.title = removeWhitespaceAtBeginning(title);
    }

    @Override
    /**
     * Sets the composer of the piece when the listener leaves the composer node.
     * @param ctx Context for composer
     */
    public void exitField_composer(ABCMusicParser.Field_composerContext ctx) {
        String composer = ctx.ICOMPOSER().getText();
        composer = composer.substring(2);
        this.composer = removeWhitespaceAtBeginning(composer);        
    }

    @Override
    /**
     * Sets the meter of the piece when the listener leaves the meter node.
     * @param ctx Context for meter 
     */
    public void exitField_meter(ABCMusicParser.Field_meterContext ctx) {
        String meter = ctx.IMETER().getText();
        meter = meter.substring(2);
        meter = removeWhitespaceAtBeginning(meter);
        if (meter.equals("C")) {
            this.meterNumerator = 4;
            this.meterDenominator = 4;
        } else {
            int slashLocation;
            for (slashLocation = 0; slashLocation < meter.length(); slashLocation++) {
                if (meter.charAt(slashLocation) == '/') {
                    break;
                }
            }
            this.meterNumerator = Integer.parseInt(meter.substring(0, slashLocation));
            this.meterDenominator = Integer.parseInt(meter.substring(slashLocation + 1));
        }
        this.currentBar = new Bar(this.meterNumerator, this.meterDenominator);
        this.currentRepeatBar = new Bar(this.meterNumerator, this.meterDenominator);
    }
    
    @Override
    /**
     * Sets the tempo of the piece when the listener leaves the tempo node.
     * @param ctx Context for tempo
     */
    public void exitField_tempo(ABCMusicParser.Field_tempoContext ctx) {
        hasTempo = true;
        String tempo = ctx.ITEMPO().getText();
        tempo = tempo.substring(2);
        tempo = removeWhitespaceAtBeginning(tempo);
        int slashLocation, equalLocation;
        for (slashLocation = 0; slashLocation < tempo.length();  slashLocation++) {
            if(tempo.charAt(slashLocation) == '/') {
                break;
            }
        }
        for (equalLocation = 0; equalLocation < tempo.length(); equalLocation++) {
            if(tempo.charAt(equalLocation) == '=') {
                break;
            }
        }
        
        this.tempoNumerator = Integer.parseInt(tempo.substring(0, slashLocation));
        this.tempoDenominator = Integer.parseInt(tempo.substring(slashLocation + 1, equalLocation));
        this.tempoSpeed = Integer.parseInt(tempo.substring(equalLocation + 1));
    }

    @Override
    /**
     * Sets the tempo of the piece when the listener leaves the tempo node.
     * @param ctx Context for tempo
     */
    public void exitField_key(ABCMusicParser.Field_keyContext ctx) {
        String key = ctx.IKEY().getText();
        key= key.substring(2);
        this.key= removeWhitespaceAtBeginning(key);
    }

    @Override
    /**
     * Sets the default note length of the piece when the listener leaves the default length node.
     * @param ctx Context for default note length
     */
    public void exitField_default_length(ABCMusicParser.Field_default_lengthContext ctx) {
        hasDefaultLength = true;
        String length = ctx.ILENGTH().getText();
        length = length.substring(2);
        length = removeWhitespaceAtBeginning(length);
        // TODO: Java has a built-in method for this I think. I was too sleepy to use it so we should change it later.
        // Also make sure that the functionality is the same.
        int slashLocation;
        for (slashLocation = 0; slashLocation < length.length();  slashLocation++) {
            if(length.charAt(slashLocation) == '/') {
                break;
            }
        }
        this.lengthNumerator = Integer.parseInt(length.substring(0, slashLocation));
        this.lengthDenominator = Integer.parseInt(length.substring(slashLocation + 1));
    }

//    @Override 
    /**
     * Sets the voices of the piece in the header when the listener leaves the voice nodes.
     * @param ctx Context for voices 
     */
//    public void exitField_voice(ABCMusicParser.Field_voiceContext ctx) { 
//    	String voice = ctx.IVOICE().getText();
//    	voice = voice.substring(2);
//    	voice = removeWhitespaceAtBeginning(voice);
//    	
//    	if (!voiceHash.containsKey(voice)) {
//            voiceHash.put(voice, new Voice(true, false, this.currentRepeatBar, this.repeatBars));
//    	}
//    }
    
    @Override
    /**
     * Initializes parameters for the abc file that were missing in the header.
     * @param ctx Context for the header
     */
    public void exitAbc_header(ABCMusicParser.Abc_headerContext ctx) {
        this.isRepeatOn = true;
        this.isOneTwoRepeat = false;
        if (!hasDefaultLength) {
            if (this.meterNumerator * 1.0 / this.meterDenominator < 0.75) {
                this.lengthNumerator = 1;
                this.lengthDenominator = 16;
            } else {
                this.lengthNumerator = 1;
                this.lengthDenominator = 8;
            }
        } else if (!hasTempo) {
            this.tempoSpeed = 100;
            this.tempoNumerator = this.lengthNumerator;
            this.tempoDenominator = this.lengthDenominator;
        }
    }

    //
    // METHODS FOR HANDLING THE BODY
    //
    
    //
    // Handling a note
    //
    
    @Override    
    /**
     * Produces a pitch when entering a pitch note, temporarily ignoring octaves.
     * @param ctx Context for the pitch note.
     */
    public void enterPitch(ABCMusicParser.PitchContext ctx) {
        this.baseNote = ctx.BASENOTE().getText();
        this.pitch = pitchCalculator.getPitchForKey(this.key, this.baseNote);            
        if (this.measureAccidentals.containsKey(this.baseNote)) {
            this.pitch = this.pitch.transpose(this.measureAccidentals.get(this.baseNote));
        }        
    }   
    
    @Override
    /** 
     * Produces a new pitch based off the accidental and the current pitch.
     * This is because having an accidental means we need to recalculate the pitch
     * instead of following the key signature.
     * @param ctx Context for accidental note.
     */
    public void exitAccidental(ABCMusicParser.AccidentalContext ctx) {
        int accidentalTranspose = 0;
        if (ctx.start.getType() == ABCMusicLexer.SHARP) {
            String accidental = ctx.SHARP().getText();
            this.pitch = pitchCalculator.getPitchForKey("C", this.baseNote);
            this.pitch = this.pitch.transpose(accidental.length());
            accidentalTranspose = accidental.length();
        } else if (ctx.start.getType() == ABCMusicLexer.NEUTRAL) {
            this.pitch = pitchCalculator.getPitchForKey("C", this.baseNote);
        } else if (ctx.start.getType() == ABCMusicLexer.FLAT) {
            String accidental = ctx.FLAT().getText();
            this.pitch = pitchCalculator.getPitchForKey("C", this.baseNote);
            this.pitch = this.pitch.transpose(-1 * accidental.length());
            accidentalTranspose = -1 * accidental.length();            
        }
        if (this.measureAccidentals.containsKey(this.baseNote)) {
            this.measureAccidentals.remove(this.baseNote);
            this.measureAccidentals.put(this.baseNote, accidentalTranspose);
        }
    }

	@Override
	/**
	 * Modifies pitch to be the correct octave.
	 * @param ctx Context for a pitch note
	 */
	public void exitPitch(ABCMusicParser.PitchContext ctx) {
	    if (ctx.OCTAVE() != null) {
	        String octave = ctx.OCTAVE().getText();
            for (int i = 0; i < octave.length(); i++) {
                if (octave.charAt(i) == ',') {
                    this.pitch = this.pitch.transpose(-Pitch.OCTAVE);
                } else {
                    this.pitch = this.pitch.transpose(Pitch.OCTAVE);
                }
            }           	        
	    }
	}
	
	@Override
	/**
	 * Sets the length of the note in the appropriate instance variable.
	 * @param ctx Context for the note length
	 */
	public void exitNote_length(ABCMusicParser.Note_lengthContext ctx) {
	    if(ctx.parent.getClass() == ABCMusicParser.NoteContext.class || ctx.parent.getClass() == ABCMusicParser.Note_or_restContext.class)  {
    	    if (ctx.NUMBER().size() > 1) {
    	        this.noteNumerator = Integer.parseInt(ctx.NUMBER(0).getText()) * this.lengthNumerator;
    	        this.noteDenominator = Integer.parseInt(ctx.NUMBER(1).getText()) * this.lengthDenominator;	        
    	    } else if (ctx.NUMBER().size() > 0) {
    	        if (ctx.SLASH() != null) {
    	            // TODO: 3 /
                    if (ctx.getChild(0).getText().equals("/")) {
                        this.noteNumerator = this.lengthNumerator;
                        this.noteDenominator = Integer.parseInt(ctx.NUMBER(0).getText()) * this.lengthDenominator;                                     
                    } else {
                        this.noteNumerator = Integer.parseInt(ctx.NUMBER(0).getText()) * this.lengthNumerator;
                        this.noteDenominator = this.lengthDenominator * 2;
                    }
    	        } else {
    	            this.noteNumerator = this.lengthNumerator * Integer.parseInt(ctx.NUMBER(0).getText());
    	            this.noteDenominator = this.lengthDenominator;
    	        }
    	    } else {
    	        if (ctx.SLASH() != null) {
    	            this.noteNumerator = this.lengthNumerator;
    	            this.noteDenominator = this.lengthDenominator * 2;	            
    	        } else {
    	            this.noteNumerator = this.lengthNumerator;
    	            this.noteDenominator = this.lengthDenominator;
    	        }
    	    }
        } else {
            if (ctx.NUMBER().size() > 1) {
                this.chordN = Integer.parseInt(ctx.NUMBER(0).getText());
                this.chordD = Integer.parseInt(ctx.NUMBER(1).getText());          
            } else if (ctx.NUMBER().size() > 0) {
                if (ctx.SLASH() != null) {
                    if (ctx.getChild(0).getText().equals("/")) {
                        this.chordN= 1;
                        this.chordD= Integer.parseInt(ctx.NUMBER(0).getText());                                     
                    } else {
                        this.chordN= Integer.parseInt(ctx.NUMBER(0).getText());
                        this.chordD= 2;
                    }
                } else {
                    this.chordN = Integer.parseInt(ctx.NUMBER(0).getText());
                    this.chordD = 1;
                }
            } else {
                if (ctx.SLASH() != null) {
                    this.chordN = 1;
                    this.chordD = 2;              
                } else {
                    this.chordN = 1;
                    this.chordD = 1;
                }
            }
        }
    }

	@Override
	/**
	 * Resets the notes in a chord to be empty and sets the instance variable isChord to be true
	 * (meaning we have entered a chord).
	 * @ctx Context for multi note
	 */
	public void enterMulti_note(ABCMusicParser.Multi_noteContext ctx) {
	    this.isChord = true;
	    this.chord = new ArrayList<Note>();
	}
	
	@Override
    /**
     * Adds the chord to our list of notes
     * @ctx Context for multi note
     */
	public void exitMulti_note(ABCMusicParser.Multi_noteContext ctx) {
	    this.isChord= false;
	    int chordNotes[] = new int[chord.size()];
	    int chordNumerator = chord.get(0).getNumerator();
        int chordDenominator = chord.get(0).getDenominator();
        for (int note = 0; note < chord.size(); note++) {
            chordNotes[note] = chord.get(note).getNote()[0];
        }
        Note theChord = new PitchNote(chordNumerator * this.chordN, 
                                                                        chordDenominator * this.chordD, 
                                                                        chordNotes, "");
        if (isTuplet) {
            this.tuplet.add(theChord);            
        } else {
            this.currentBar.addNote(theChord);
            if (isRepeatOn && !isOneTwoRepeat) {
                this.currentRepeatBar.addNote(theChord);
            }
        }

	}

	
    @Override
    /**
     * Resets the notes in a tuplet to be empty and sets the instance variable isTuplet to be true
     * (meaning we have entered a tuplet).
     * @ctx Context for tuplet
     */
    public void enterTuplet_element(ABCMusicParser.Tuplet_elementContext ctx) {
       this.isTuplet = true;
       this.tuplet = new ArrayList<Note>();
    }

	@Override
    /**
     * Adds the notes in the tuplet to our list of notes
     * @ctx Context for tuplet
     */
	public void exitTuplet_element(ABCMusicParser.Tuplet_elementContext ctx) {
	    String tupletSpec = ctx.TUPLET_SPEC().getText();
	    
	    // TODO: Magic numbers (here and throughout)
	    if (tupletSpec.substring(1).equals("3")) {
	        if (this.tuplet.size() != 3) {
	            // TODO: throw error
	        }
	        
	        for (int i = 0; i < 3; i++) {
	            int noteNumerator = this.tuplet.get(i).getNumerator();
	            int noteDenominator = this.tuplet.get(i).getDenominator();
	            this.currentBar.addNote(new PitchNote(noteNumerator * 2, noteDenominator * 3, this.tuplet.get(i).getNote(), ""));
                if (this.isRepeatOn && !this.isOneTwoRepeat) {
                    this.currentRepeatBar.addNote(new PitchNote(noteNumerator * 2, noteDenominator * 3, this.tuplet.get(i).getNote(), ""));
                }
	        }	       
	    } else if (tupletSpec.substring(1).equals("2")) {
            if (this.tuplet.size() != 2) {
                // throw error
            }
            for (int i = 0; i < 2; i++) {
                int noteNumerator = this.tuplet.get(i).getNumerator();
                int noteDenominator = this.tuplet.get(i).getDenominator();
                this.currentBar.addNote(new PitchNote(noteNumerator * 3, noteDenominator * 2, this.tuplet.get(i).getNote(), ""));
                if (this.isRepeatOn && !this.isOneTwoRepeat) {
                    this.currentRepeatBar.addNote(new PitchNote(noteNumerator * 3, noteDenominator * 2, this.tuplet.get(i).getNote(), ""));
                }
            }          
	    } else {
            if (this.tuplet.size() != 4) {
                // throw error
            }
            for (int i = 0; i < 4; i++) {
                int noteNumerator = this.tuplet.get(i).getNumerator();
                int noteDenominator = this.tuplet.get(i).getDenominator();
                this.currentBar.addNote(new PitchNote(noteNumerator * 3, noteDenominator * 4, this.tuplet.get(i).getNote(), ""));
                if (this.isRepeatOn && !this.isOneTwoRepeat) {
                    this.currentRepeatBar.addNote(new PitchNote(noteNumerator * 3, noteDenominator * 4, this.tuplet.get(i).getNote(), ""));
                }
            }
	        
	    }
        this.isTuplet = false;
	}
	
	@Override 
    /**
     * Adds the note to the appropriate place (chord, tuplet, or bar)
     * @param ctx Context for note
     */
	public void exitNote(ABCMusicParser.NoteContext ctx) { 
	    if (this.isChord) {
	        this.chord.add(new PitchNote(this.noteNumerator, this.noteDenominator, new int[] {pitch.toMidiNote()}, ""));
	    } else if (this.isTuplet) {
	        this.tuplet.add(new PitchNote(this.noteNumerator, this.noteDenominator, new int[] {pitch.toMidiNote()}, ""));
	    } else {
            if (this.pitch != null) {
                int[] notes = {this.pitch.toMidiNote()};
                this.currentBar.addNote(new PitchNote(this.noteNumerator, this.noteDenominator, notes, ""));
                if (this.isRepeatOn && !this.isOneTwoRepeat) {
                    this.currentRepeatBar.addNote(new PitchNote(this.noteNumerator, this.noteDenominator, notes, ""));
                }
                this.pitch = null;
            } else {
                this.currentBar.addNote(new RestNote(this.noteNumerator, this.noteDenominator));
                if (isRepeatOn && !isOneTwoRepeat) {
                    this.currentRepeatBar.addNote(new RestNote(this.noteNumerator, this.noteDenominator));
                }
            }
	    }
	}
	
	@Override
	/**
	 * Sets the pitch null if we've exited a rest.
	 * @param ctx Context for note_or_rest
	 */
	public void exitNote_or_rest(ABCMusicParser.Note_or_restContext ctx) {
	    if (ctx.REST() != null) {
	        this.pitch = null;
	    }
	}
	
	@Override
	/**
	 * Checks the type of bar and turns on or off repeats accordingly. 
	 * Adds the bar to our list of bars.
	 * @param ctx Context for element
	 */
	public void exitElement(ABCMusicParser.ElementContext ctx) {
	    if (ctx.start.getType() == ABCMusicLexer.BAR) {
	        String bar = ctx.BAR().getText();
            this.measureAccidentals = new HashMap<String, Integer>();

	        if (bar.equals("|") || bar.equals("||") || bar.equals("|]") || bar.equals("|[")) {
	            // If we're in a repeat section and it's not inside the [1 [2 part of it,
	            // add this bar to the list of bars to repeat
	            // make a new bar as the current repeat bar
                if (this.isRepeatOn && !this.isOneTwoRepeat && this.currentRepeatBar.getNotes().size() > 0) {
	                this.repeatBars.add(new Bar(this.currentRepeatBar));
	                this.currentRepeatBar = new Bar(this.meterNumerator, this.meterDenominator);
	            }
	            this.bars.add(new Bar(this.currentBar));
                this.barsInLine.add(new Bar(this.currentBar));
	            this.currentBar = new Bar(this.meterNumerator, this.meterDenominator);
	        } else if (bar.equals("|:")) {
	            this.isRepeatOn = true;
	            this.repeatBars = new ArrayList<Bar>();
	        } else if (bar.equals(":|")) {
                this.isRepeatOn = false;
	            this.bars.add(new Bar(this.currentBar));
                this.barsInLine.add(new Bar(this.currentBar));
	            this.currentBar = new Bar(this.meterNumerator, this.meterDenominator);
	            this.repeatBars.add(this.currentRepeatBar);
	            this.currentRepeatBar = new Bar(this.meterNumerator, this.meterDenominator);
	            for (int repeatBar = 0; repeatBar < this.repeatBars.size(); repeatBar++) {
	                this.bars.add(this.repeatBars.get(repeatBar));
	            }
	        }
	    }
	    
	    if (ctx.start.getType() == ABCMusicLexer.NTH_REPEAT) {
	        String nthRepeat = ctx.NTH_REPEAT().getText();
	        if (nthRepeat.equals("[1")) {
	            this.isOneTwoRepeat = true;
	        } else if (nthRepeat.equals("[2")) {
	            this.isOneTwoRepeat = false;
	        }
	    }
	}

	@Override
	/**
	 * Updates the voice and adds the notes associated with the old voice into the voiceHash hash map.
	 * @param ctx Context for voice
	 */
	public void enterMid_tune_field(ABCMusicParser.Mid_tune_fieldContext ctx) {
        if (!this.voiceHash.containsKey(this.currentVoice)) {
            this.voiceHash.put(this.currentVoice, new Voice(this.isRepeatOn, this.isOneTwoRepeat, this.currentRepeatBar, this.repeatBars));
        } else{
            this.voiceHash.get(this.currentVoice).setRepeatOn(this.isRepeatOn);
            this.voiceHash.get(this.currentVoice).setOneTwoRepeat(this.isOneTwoRepeat);
            this.voiceHash.get(this.currentVoice).setCurrentRepeatBar(this.currentRepeatBar);
            this.voiceHash.get(this.currentVoice).setRepeatBars(this.repeatBars);
        }
        this.voiceHash.get(this.currentVoice).addBars(this.bars);
        this.bars = new ArrayList<Bar>();	

        String voice = ctx.IVOICE().getText().substring(2);
	    voice = removeWhitespaceAtBeginning(voice);
	    this.currentVoice = voice;
	    
	    // This means this is the first time that this voice has appeared.
	    Voice currentVoiceValue = this.voiceHash.get(this.currentVoice);
	    if (currentVoiceValue == null) {
	        this.isRepeatOn = true;
	        this.isOneTwoRepeat = false;
	        this.currentRepeatBar = new Bar(this.meterNumerator, this.meterDenominator);
	        this.repeatBars = new ArrayList<Bar>();
	    } else {
	        this.isRepeatOn = currentVoiceValue.getRepeatOn();
            this.isOneTwoRepeat = currentVoiceValue.getOneTwoRepeat();
            this.currentRepeatBar = currentVoiceValue.getCurrentRepeatBar();
            this.repeatBars = currentVoiceValue.getRepeatBars();
	    }
	}

	@Override
	/**
	 * Resets the bars in the line to be empty.
	 * @param ctx Context for abc line
	 */
	public void enterAbc_line(ABCMusicParser.Abc_lineContext ctx) {
	    this.barsInLine = new ArrayList<Bar>();
	}

	@Override
	/**
	 * Adds the lyrics to the line if there are any.
	 * @param ctx Context for abc line
	 */
	public void exitAbc_line(ABCMusicParser.Abc_lineContext ctx) {
	    
	    if (ctx.ILYRIC() != null) {
	        String lyrics = ctx.ILYRIC().getText();
	        lyrics = lyrics.substring(2);
	        lyrics = removeWhitespaceAtBeginning(lyrics);

            CharStream stream = new ANTLRInputStream(lyrics);
            ABCLyricLexer lexer = new ABCLyricLexer(stream);
            lexer.reportErrorsAsExceptions();
            TokenStream tokens = new CommonTokenStream(lexer);
            
            // Feed the tokens into the parser.
            ABCLyricParser parser = new ABCLyricParser(tokens);
            parser.reportErrorsAsExceptions();
            
            // Generate the parse tree using the starter rule.
            ParseTree tree;
            tree = parser.lyric(); // "line" is the starter rule.
           
            ParseTreeWalker walker = new ParseTreeWalker();
            ParseTreeListener listener = new PlayerLyricListener(this.barsInLine);
            walker.walk(listener, tree);
            ArrayList<Bar> barsWithLyrics = ((PlayerLyricListener) listener).getBarsInLine();
            for(int i =0 ; i < barsWithLyrics.size(); i++) {
                for (int j = 0; j < this.barsInLine.get(i).getNotes().size(); j++) {
                    this.barsInLine.get(i).getNotes().get(j).setLyric(barsWithLyrics.get(i).getNotes().get(j).getLyric());
                }
            }
	    }
	}
	
	@Override
	/**
	 * Adds the last voice to the voiceHash map and then adds the phrases from the hash map
	 * to our phrases array list.
	 * @param ctx Context for abc music
	 */
	public void exitAbc_music(ABCMusicParser.Abc_musicContext ctx) {
        if (!this.voiceHash.containsKey(this.currentVoice)) {
            this.voiceHash.put(this.currentVoice, new Voice(this.isRepeatOn, this.isOneTwoRepeat, this.currentRepeatBar, this.repeatBars));
        }
        this.voiceHash.get(this.currentVoice).addBars(this.bars);
        this.bars = new ArrayList<Bar>();
        for (Entry<String, Voice> entry : voiceHash.entrySet()) {
            this.phrases.add(new MusicalPhrase(entry.getValue().getVoiceBars()));
        }
	}
	
}
